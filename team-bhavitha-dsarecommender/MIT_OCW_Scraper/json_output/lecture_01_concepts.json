[
  {
    "title": "Algorithms",
    "content": "WELCOME!\n(download slides and .py files and follow along!)\n6.0001 LECTURE 1\n1\n6.0001 LECTURE 1\nTODAY\n\uf0a7course info\n\uf0a7what is computation\n\uf0a7python basics\n\uf0a7mathematical operations\n\uf0a7python variables and types\n\uf0a7NOTE: slides and code files up before each lecture\no highly encourage you to download them before lecture\no take notes and run code files when I do\no bring computers to answer in-class practice exercises!\n2\n6.0001 LECTURE 1\nCOURSE INFO\n\uf0a7Grading\n\u25e6approx. 20%  Quiz\n\u25e6approx. 40%  Final \n\u25e6approx. 30%  Problem Sets \n\u25e6approx. 10%  MITx Finger Exercises\n3\n6.0001 LECTURE 1\nCOURSE POLICIES\n\uf0a7Collaboration\n\u25e6may collaborate with anyone\n\u25e6required to write code independently and write names of \nall collaborators on submission\n\u25e6we will be running a code similarity program on all psets\n\uf0a7Extensions\n\u25e6no extensions\n\u25e6late days, see course website for details\n\u25e6drop and roll weight of max two psets in final exam grade\n\u25e6should be EMERGENCY use only\n4\n6.0001 LECTURE 1\nRECITATIONS\n\uf0a7not mandatory\n\uf0a7two flavors\n1) Lecture review: review lecture material \no if you missed lecture \no if you need a different take on the same concepts\n2) Problem solving: teach you how to solve programming \nproblems\no useful if you don\u2019t know how to set up pseudocode from pset words \no we show a couple of harder questions\no walk you through how to approach solving the problem\no brainstorm code solution along with the recitation instructor\no will post solutions after\n6.0001 LECTURE 1\n5\nFAST PACED COURSE\n\uf0a7Position yourself to succeed!\n\u25e6read psets when they come out and come back to them later\n\u25e6use late days in emergency situations\n\uf0a7New to programming? PRACTICE. PRACTICE? PRACTICE! \n\u25e6can\u2019t passively absorb programming as a skill\n\u25e6download code before lecture and follow along\n\u25e6do MITx finger exercises \n\u25e6don\u2019t be afraid to try out Python commands! \n6\n6.0001 LECTURE 1\nPRACTICE\n7\n6.0001 LECTURE 1\nPROBLEM \nSOLVING\nPROGRAMMING \nSKILL\nKNOWLEDGE \nOF CONCEPTS\nTOPICS\n\uf0a7represent knowledge with data structures\n\uf0a7iteration and recursion as computational metaphors\n\uf0a7abstraction of procedures and data types\n\uf0a7organize and modularize systems using object classes \nand methods\n\uf0a7different classes of algorithms, searching and sorting\n\uf0a7complexity of algorithms\n6.0001 LECTURE 1\n8\nWHAT DOES A COMPUTER DO\n\uf0a7Fundamentally:\n\u25e6performs calculations\na billion calculations per second!\n\u25e6remembers results\n100s of gigabytes of storage!\n\uf0a7What kinds of calculations?\n\u25e6built-in to the language\n\u25e6ones that you define as the programmer\n\uf0a7computers only know what you tell them\n6.0001 LECTURE 1\n9\nTYPES OF KNOWLEDGE\n\uf0a7declarative knowledge is statements of fact. \n\u25e6someone will win a Google \nCardboard before class ends\n\uf0a7imperative knowledge is a recipe or \u201chow-to\u201d.  \n1) Students sign up for raffle\n2) Ana opens her IDE\n3) Ana chooses a random number between 1st and nth responder\n4) Ana finds the number in the responders sheet. Winner!\n6.0001 LECTURE 1\n10\nA NUMERICAL EXAMPLE\n\uf0a7square root of a number x is y such that y*y = x\n\uf0a7recipe for deducing square root of a number x (16)\n1) Start with a guess, g\n2) If g*g is close enough to x, stop and say g is the \nanswer \n3) Otherwise make a new guess by averaging g and x/g\n4) Using the new guess, repeat process until close enough\n6.0001 LECTURE 1\n11\ng\ng*g\nx/g\n(g+x/g)/2\n3\n9\n16/3\n4.17\n4.17\n17.36\n3.837\n4.0035\n4.0035\n16.0277\n3.997\n4.000002\nWHAT IS A RECIPE\n1)\nsequence of simple steps\n2)\nflow of control process that specifies when each \nstep is executed\n3)\na means of determining when to stop\n1+2+3 = an algorithm!\n6.0001 LECTURE 1\n12\nCOMPUTERS ARE MACHINES\n\uf0a7how to capture a recipe in a mechanical process\n\uf0a7fixed program computer\n\u25e6calculator\n\uf0a7stored program computer\n\u25e6machine stores and executes instructions\n6.0001 LECTURE 1\n13\nBASIC MACHINE ARCHITECTURE\n6.0001 LECTURE 1\n14\nMEMORY\nCONTROL \nUNIT\nARITHMETIC \nLOGIC UNIT\nINPUT\nOUTPUT\nprogram counter\ndo primitive ops\nSTORED PROGRAM COMPUTER\n\uf0a7sequence of instructions stored inside computer\n\u25e6built from predefined set of primitive instructions\n1)\narithmetic and logic\n2)\nsimple tests\n3)\nmoving data\n\uf0a7special program (interpreter) executes each \ninstruction in order\n\u25e6use tests to change flow of control through sequence\n\u25e6stop when done\n6.0001 LECTURE 1\n15\nBASIC PRIMITIVES\n\uf0a7Turing showed that you can compute anything using 6 \nprimitives\n\uf0a7modern programming languages have more \nconvenient set of primitives\n\uf0a7can abstract methods to create new primitives\n\uf0a7anything computable in one language is computable in \nany other programming language\n6.0001 LECTURE 1\n16\nCREATING RECIPES\n\uf0a7a programming language provides a set of primitive \noperations\n\uf0a7expressions are complex but legal combinations of \nprimitives in a programming language\n\uf0a7expressions and computations have values and \nmeanings in a programming language\n6.0001 LECTURE 1\n17\nASPECTS OF LANGUAGES\n\uf0a7primitive constructs\n\u25e6English: words\n\u25e6programming language: numbers, strings, simple \noperators\n6.0001 LECTURE 1\n18\nWord Cloud copyright Michael Twardos, All Right Reserved. This content is excluded from our\nCreative Commons license. For more information, see https://ocw.mit.edu/help/faq-fair-use/.\nWord Cloud copyright unknown, All Right Reserved.\nThis content is excluded from our Creative\nCommons license. For more information, see\nhttps://ocw.mit.edu/help/faq-fair-use/.\nASPECTS OF LANGUAGES\n\uf0a7syntax\n\u25e6English: \"cat dog boy\"    \uf0e0not syntactically valid\n\"cat hugs boy\" \uf0e0syntactically valid\n\u25e6programming language: \"hi\"5 \uf0e0not syntactically valid\n3.2*5 \uf0e0syntactically valid\n6.0001 LECTURE 1\n19\nASPECTS OF LANGUAGES\n\uf0a7static semantics is which syntactically valid strings \nhave meaning\n\u25e6English: \"I are hungry\" \uf0e0syntactically valid\nbut static semantic error\n\u25e6programming language: 3.2*5\n\uf0e0syntactically valid\n3+\"hi\" \uf0e0static semantic error\n6.0001 LECTURE 1\n20\nASPECTS OF LANGUAGES\n\uf0a7semantics is the meaning associated with a \nsyntactically correct string of symbols with no static \nsemantic errors\n\u25e6English: can have many meanings \"Flying planes \ncan be dangerous\"\n\u25e6programming languages: have only one meaning but may \nnot be what programmer intended\n6.0001 LECTURE 1\n21\nWHERE THINGS GO WRONG\n\uf0a7syntactic errors\n\u25e6common and easily caught\n\uf0a7static semantic errors\n\u25e6some languages check for these before running program\n\u25e6can cause unpredictable behavior\n\uf0a7no semantic errors but different meaning than what \nprogrammer intended\n\u25e6program crashes, stops running\n\u25e6program runs forever\n\u25e6program gives an answer but different than expected\n6.0001 LECTURE 1\n22\nPYTHON PROGRAMS\n\uf0a7a program is a sequence of definitions and commands\n\u25e6definitions evaluated \n\u25e6commands executed by Python interpreter in a shell\n\uf0a7commands (statements) instruct interpreter to do \nsomething\n\uf0a7can be typed directly in a shell or stored in a file that \nis read into the shell and evaluated\n\u25e6Problem Set 0 will introduce you to these in Anaconda\n6.0001 LECTURE 1\n23\nOBJECTS\n\uf0a7programs manipulate data objects\n\uf0a7objects have a type that defines the kinds of things \nprograms can do to them\n\u25e6Ana is a human so she can walk, speak English, etc.\n\u25e6Chewbacca is a wookie so he can walk, \u201cmwaaarhrhh\u201d, etc.\n\uf0a7objects are\n\u25e6scalar (cannot be subdivided)\n\u25e6non-scalar (have internal structure that can be accessed)\n6.0001 LECTURE 1\n24\nSCALAR OBJECTS\n\uf0a7int \u2013 represent integers, ex. 5\n\uf0a7float \u2013 represent real numbers, ex. 3.27\n\uf0a7bool \u2013 represent Boolean values True and False\n\uf0a7NoneType \u2013 special and has one value, None\n\uf0a7can use type() to see the type of an object\n>>> type(5)\nint\n>>> type(3.0)\nfloat\n6.0001 LECTURE 1\n25\nTYPE CONVERSIONS (CAST)\n\uf0a7can convert object of one type to another\n\uf0a7float(3) converts integer 3 to float 3.0\n\uf0a7int(3.9) truncates float 3.9 to integer 3\n6.0001 LECTURE 1\n26\nPRINTING TO CONSOLE\n\uf0a7to show output from code to a user, use print\ncommand\nIn [11]: 3+2\nOut[11]: 5\nIn [12]: print(3+2)\n5\n6.0001 LECTURE 1\n27\nEXPRESSIONS\n\uf0a7combine objects and operators to form expressions\n\uf0a7an expression has a value, which has a type\n\uf0a7syntax for a simple expression\n<object> <operator> <object>\n6.0001 LECTURE 1\n28\nOPERATORS ON ints and floats\n\uf0a7i+j\n\uf0e0the sum\n\uf0a7i-j\n\uf0e0the difference\n\uf0a7i*j\n\uf0e0the product\n\uf0a7i/j\n\uf0e0division\n\uf0a7i%j\n\uf0e0the remainder when i is divided by j\n\uf0a7i**j \uf0e0i to the power of j\n6.0001 LECTURE 1\n29\nif both are ints, result is int\nif either or both are floats, result is float\nresult is float\nSIMPLE OPERATIONS\n\uf0a7parentheses used to tell Python to do these \noperations first\n\uf0a7operator precedence without parentheses\n\u25e6**\n\u25e6*\n\u25e6/\n\u25e6+ and \u2013 executed left to right, as appear in expression\n6.0001 LECTURE 1\n30\nBINDING VARIABLES AND \nVALUES\n\uf0a7equal sign is an assignment of a value to a variable \nname\npi = 3.14159\npi_approx = 22/7\n\uf0a7value stored in computer memory\n\uf0a7an assignment binds name to value\n\uf0a7retrieve value associated with name or variable by \ninvoking the name, by typing pi\n6.0001 LECTURE 1\n31\nABSTRACTING EXPRESSIONS\n\uf0a7why give names to values of expressions?\n\uf0a7to reuse names instead of values\n\uf0a7easier to change code later\npi = 3.14159\nradius = 2.2\narea = pi*(radius**2)\n6.0001 LECTURE 1\n32\nPROGRAMMING vs MATH\n\uf0a7in programming, you do not \u201csolve for x\u201d\npi = 3.14159\nradius = 2.2\n# area of circle\narea = pi*(radius**2)\nradius = radius+1\n6.0001 LECTURE 1\n33\nCHANGING BINDINGS\n\uf0a7can re-bind variable names using new assignment \nstatements\n\uf0a7previous value may still stored in memory but lost the \nhandle for it\n\uf0a7value for area does not change until you tell the \ncomputer to do the calculation again\n6.0001 LECTURE 1\n34\npi\nradius\narea\n3.14\n2.2\n15.1976\n3.2\npi = 3.14\nradius = 2.2\narea = pi*(radius**2)\nradius = radius+1\nMIT OpenCourseWare\nhttps://ocw.mit.edu\n6.0001 Introduction to Computer Science and Programming in Python\nFall  2016\nFor information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms."
  },
  {
    "title": "Variables",
    "content": "WELCOME!\n(download slides and .py files and follow along!)\n6.0001 LECTURE 1\n1\n6.0001 LECTURE 1\nTODAY\n\uf0a7course info\n\uf0a7what is computation\n\uf0a7python basics\n\uf0a7mathematical operations\n\uf0a7python variables and types\n\uf0a7NOTE: slides and code files up before each lecture\no highly encourage you to download them before lecture\no take notes and run code files when I do\no bring computers to answer in-class practice exercises!\n2\n6.0001 LECTURE 1\nCOURSE INFO\n\uf0a7Grading\n\u25e6approx. 20%  Quiz\n\u25e6approx. 40%  Final \n\u25e6approx. 30%  Problem Sets \n\u25e6approx. 10%  MITx Finger Exercises\n3\n6.0001 LECTURE 1\nCOURSE POLICIES\n\uf0a7Collaboration\n\u25e6may collaborate with anyone\n\u25e6required to write code independently and write names of \nall collaborators on submission\n\u25e6we will be running a code similarity program on all psets\n\uf0a7Extensions\n\u25e6no extensions\n\u25e6late days, see course website for details\n\u25e6drop and roll weight of max two psets in final exam grade\n\u25e6should be EMERGENCY use only\n4\n6.0001 LECTURE 1\nRECITATIONS\n\uf0a7not mandatory\n\uf0a7two flavors\n1) Lecture review: review lecture material \no if you missed lecture \no if you need a different take on the same concepts\n2) Problem solving: teach you how to solve programming \nproblems\no useful if you don\u2019t know how to set up pseudocode from pset words \no we show a couple of harder questions\no walk you through how to approach solving the problem\no brainstorm code solution along with the recitation instructor\no will post solutions after\n6.0001 LECTURE 1\n5\nFAST PACED COURSE\n\uf0a7Position yourself to succeed!\n\u25e6read psets when they come out and come back to them later\n\u25e6use late days in emergency situations\n\uf0a7New to programming? PRACTICE. PRACTICE? PRACTICE! \n\u25e6can\u2019t passively absorb programming as a skill\n\u25e6download code before lecture and follow along\n\u25e6do MITx finger exercises \n\u25e6don\u2019t be afraid to try out Python commands! \n6\n6.0001 LECTURE 1\nPRACTICE\n7\n6.0001 LECTURE 1\nPROBLEM \nSOLVING\nPROGRAMMING \nSKILL\nKNOWLEDGE \nOF CONCEPTS\nTOPICS\n\uf0a7represent knowledge with data structures\n\uf0a7iteration and recursion as computational metaphors\n\uf0a7abstraction of procedures and data types\n\uf0a7organize and modularize systems using object classes \nand methods\n\uf0a7different classes of algorithms, searching and sorting\n\uf0a7complexity of algorithms\n6.0001 LECTURE 1\n8\nWHAT DOES A COMPUTER DO\n\uf0a7Fundamentally:\n\u25e6performs calculations\na billion calculations per second!\n\u25e6remembers results\n100s of gigabytes of storage!\n\uf0a7What kinds of calculations?\n\u25e6built-in to the language\n\u25e6ones that you define as the programmer\n\uf0a7computers only know what you tell them\n6.0001 LECTURE 1\n9\nTYPES OF KNOWLEDGE\n\uf0a7declarative knowledge is statements of fact. \n\u25e6someone will win a Google \nCardboard before class ends\n\uf0a7imperative knowledge is a recipe or \u201chow-to\u201d.  \n1) Students sign up for raffle\n2) Ana opens her IDE\n3) Ana chooses a random number between 1st and nth responder\n4) Ana finds the number in the responders sheet. Winner!\n6.0001 LECTURE 1\n10\nA NUMERICAL EXAMPLE\n\uf0a7square root of a number x is y such that y*y = x\n\uf0a7recipe for deducing square root of a number x (16)\n1) Start with a guess, g\n2) If g*g is close enough to x, stop and say g is the \nanswer \n3) Otherwise make a new guess by averaging g and x/g\n4) Using the new guess, repeat process until close enough\n6.0001 LECTURE 1\n11\ng\ng*g\nx/g\n(g+x/g)/2\n3\n9\n16/3\n4.17\n4.17\n17.36\n3.837\n4.0035\n4.0035\n16.0277\n3.997\n4.000002\nWHAT IS A RECIPE\n1)\nsequence of simple steps\n2)\nflow of control process that specifies when each \nstep is executed\n3)\na means of determining when to stop\n1+2+3 = an algorithm!\n6.0001 LECTURE 1\n12\nCOMPUTERS ARE MACHINES\n\uf0a7how to capture a recipe in a mechanical process\n\uf0a7fixed program computer\n\u25e6calculator\n\uf0a7stored program computer\n\u25e6machine stores and executes instructions\n6.0001 LECTURE 1\n13\nBASIC MACHINE ARCHITECTURE\n6.0001 LECTURE 1\n14\nMEMORY\nCONTROL \nUNIT\nARITHMETIC \nLOGIC UNIT\nINPUT\nOUTPUT\nprogram counter\ndo primitive ops\nSTORED PROGRAM COMPUTER\n\uf0a7sequence of instructions stored inside computer\n\u25e6built from predefined set of primitive instructions\n1)\narithmetic and logic\n2)\nsimple tests\n3)\nmoving data\n\uf0a7special program (interpreter) executes each \ninstruction in order\n\u25e6use tests to change flow of control through sequence\n\u25e6stop when done\n6.0001 LECTURE 1\n15\nBASIC PRIMITIVES\n\uf0a7Turing showed that you can compute anything using 6 \nprimitives\n\uf0a7modern programming languages have more \nconvenient set of primitives\n\uf0a7can abstract methods to create new primitives\n\uf0a7anything computable in one language is computable in \nany other programming language\n6.0001 LECTURE 1\n16\nCREATING RECIPES\n\uf0a7a programming language provides a set of primitive \noperations\n\uf0a7expressions are complex but legal combinations of \nprimitives in a programming language\n\uf0a7expressions and computations have values and \nmeanings in a programming language\n6.0001 LECTURE 1\n17\nASPECTS OF LANGUAGES\n\uf0a7primitive constructs\n\u25e6English: words\n\u25e6programming language: numbers, strings, simple \noperators\n6.0001 LECTURE 1\n18\nWord Cloud copyright Michael Twardos, All Right Reserved. This content is excluded from our\nCreative Commons license. For more information, see https://ocw.mit.edu/help/faq-fair-use/.\nWord Cloud copyright unknown, All Right Reserved.\nThis content is excluded from our Creative\nCommons license. For more information, see\nhttps://ocw.mit.edu/help/faq-fair-use/.\nASPECTS OF LANGUAGES\n\uf0a7syntax\n\u25e6English: \"cat dog boy\"    \uf0e0not syntactically valid\n\"cat hugs boy\" \uf0e0syntactically valid\n\u25e6programming language: \"hi\"5 \uf0e0not syntactically valid\n3.2*5 \uf0e0syntactically valid\n6.0001 LECTURE 1\n19\nASPECTS OF LANGUAGES\n\uf0a7static semantics is which syntactically valid strings \nhave meaning\n\u25e6English: \"I are hungry\" \uf0e0syntactically valid\nbut static semantic error\n\u25e6programming language: 3.2*5\n\uf0e0syntactically valid\n3+\"hi\" \uf0e0static semantic error\n6.0001 LECTURE 1\n20\nASPECTS OF LANGUAGES\n\uf0a7semantics is the meaning associated with a \nsyntactically correct string of symbols with no static \nsemantic errors\n\u25e6English: can have many meanings \"Flying planes \ncan be dangerous\"\n\u25e6programming languages: have only one meaning but may \nnot be what programmer intended\n6.0001 LECTURE 1\n21\nWHERE THINGS GO WRONG\n\uf0a7syntactic errors\n\u25e6common and easily caught\n\uf0a7static semantic errors\n\u25e6some languages check for these before running program\n\u25e6can cause unpredictable behavior\n\uf0a7no semantic errors but different meaning than what \nprogrammer intended\n\u25e6program crashes, stops running\n\u25e6program runs forever\n\u25e6program gives an answer but different than expected\n6.0001 LECTURE 1\n22\nPYTHON PROGRAMS\n\uf0a7a program is a sequence of definitions and commands\n\u25e6definitions evaluated \n\u25e6commands executed by Python interpreter in a shell\n\uf0a7commands (statements) instruct interpreter to do \nsomething\n\uf0a7can be typed directly in a shell or stored in a file that \nis read into the shell and evaluated\n\u25e6Problem Set 0 will introduce you to these in Anaconda\n6.0001 LECTURE 1\n23\nOBJECTS\n\uf0a7programs manipulate data objects\n\uf0a7objects have a type that defines the kinds of things \nprograms can do to them\n\u25e6Ana is a human so she can walk, speak English, etc.\n\u25e6Chewbacca is a wookie so he can walk, \u201cmwaaarhrhh\u201d, etc.\n\uf0a7objects are\n\u25e6scalar (cannot be subdivided)\n\u25e6non-scalar (have internal structure that can be accessed)\n6.0001 LECTURE 1\n24\nSCALAR OBJECTS\n\uf0a7int \u2013 represent integers, ex. 5\n\uf0a7float \u2013 represent real numbers, ex. 3.27\n\uf0a7bool \u2013 represent Boolean values True and False\n\uf0a7NoneType \u2013 special and has one value, None\n\uf0a7can use type() to see the type of an object\n>>> type(5)\nint\n>>> type(3.0)\nfloat\n6.0001 LECTURE 1\n25\nTYPE CONVERSIONS (CAST)\n\uf0a7can convert object of one type to another\n\uf0a7float(3) converts integer 3 to float 3.0\n\uf0a7int(3.9) truncates float 3.9 to integer 3\n6.0001 LECTURE 1\n26\nPRINTING TO CONSOLE\n\uf0a7to show output from code to a user, use print\ncommand\nIn [11]: 3+2\nOut[11]: 5\nIn [12]: print(3+2)\n5\n6.0001 LECTURE 1\n27\nEXPRESSIONS\n\uf0a7combine objects and operators to form expressions\n\uf0a7an expression has a value, which has a type\n\uf0a7syntax for a simple expression\n<object> <operator> <object>\n6.0001 LECTURE 1\n28\nOPERATORS ON ints and floats\n\uf0a7i+j\n\uf0e0the sum\n\uf0a7i-j\n\uf0e0the difference\n\uf0a7i*j\n\uf0e0the product\n\uf0a7i/j\n\uf0e0division\n\uf0a7i%j\n\uf0e0the remainder when i is divided by j\n\uf0a7i**j \uf0e0i to the power of j\n6.0001 LECTURE 1\n29\nif both are ints, result is int\nif either or both are floats, result is float\nresult is float\nSIMPLE OPERATIONS\n\uf0a7parentheses used to tell Python to do these \noperations first\n\uf0a7operator precedence without parentheses\n\u25e6**\n\u25e6*\n\u25e6/\n\u25e6+ and \u2013 executed left to right, as appear in expression\n6.0001 LECTURE 1\n30\nBINDING VARIABLES AND \nVALUES\n\uf0a7equal sign is an assignment of a value to a variable \nname\npi = 3.14159\npi_approx = 22/7\n\uf0a7value stored in computer memory\n\uf0a7an assignment binds name to value\n\uf0a7retrieve value associated with name or variable by \ninvoking the name, by typing pi\n6.0001 LECTURE 1\n31\nABSTRACTING EXPRESSIONS\n\uf0a7why give names to values of expressions?\n\uf0a7to reuse names instead of values\n\uf0a7easier to change code later\npi = 3.14159\nradius = 2.2\narea = pi*(radius**2)\n6.0001 LECTURE 1\n32\nPROGRAMMING vs MATH\n\uf0a7in programming, you do not \u201csolve for x\u201d\npi = 3.14159\nradius = 2.2\n# area of circle\narea = pi*(radius**2)\nradius = radius+1\n6.0001 LECTURE 1\n33\nCHANGING BINDINGS\n\uf0a7can re-bind variable names using new assignment \nstatements\n\uf0a7previous value may still stored in memory but lost the \nhandle for it\n\uf0a7value for area does not change until you tell the \ncomputer to do the calculation again\n6.0001 LECTURE 1\n34\npi\nradius\narea\n3.14\n2.2\n15.1976\n3.2\npi = 3.14\nradius = 2.2\narea = pi*(radius**2)\nradius = radius+1\nMIT OpenCourseWare\nhttps://ocw.mit.edu\n6.0001 Introduction to Computer Science and Programming in Python\nFall  2016\nFor information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms."
  },
  {
    "title": "Recursion",
    "content": "WELCOME!\n(download slides and .py files and follow along!)\n6.0001 LECTURE 1\n1\n6.0001 LECTURE 1\nTODAY\n\uf0a7course info\n\uf0a7what is computation\n\uf0a7python basics\n\uf0a7mathematical operations\n\uf0a7python variables and types\n\uf0a7NOTE: slides and code files up before each lecture\no highly encourage you to download them before lecture\no take notes and run code files when I do\no bring computers to answer in-class practice exercises!\n2\n6.0001 LECTURE 1\nCOURSE INFO\n\uf0a7Grading\n\u25e6approx. 20%  Quiz\n\u25e6approx. 40%  Final \n\u25e6approx. 30%  Problem Sets \n\u25e6approx. 10%  MITx Finger Exercises\n3\n6.0001 LECTURE 1\nCOURSE POLICIES\n\uf0a7Collaboration\n\u25e6may collaborate with anyone\n\u25e6required to write code independently and write names of \nall collaborators on submission\n\u25e6we will be running a code similarity program on all psets\n\uf0a7Extensions\n\u25e6no extensions\n\u25e6late days, see course website for details\n\u25e6drop and roll weight of max two psets in final exam grade\n\u25e6should be EMERGENCY use only\n4\n6.0001 LECTURE 1\nRECITATIONS\n\uf0a7not mandatory\n\uf0a7two flavors\n1) Lecture review: review lecture material \no if you missed lecture \no if you need a different take on the same concepts\n2) Problem solving: teach you how to solve programming \nproblems\no useful if you don\u2019t know how to set up pseudocode from pset words \no we show a couple of harder questions\no walk you through how to approach solving the problem\no brainstorm code solution along with the recitation instructor\no will post solutions after\n6.0001 LECTURE 1\n5\nFAST PACED COURSE\n\uf0a7Position yourself to succeed!\n\u25e6read psets when they come out and come back to them later\n\u25e6use late days in emergency situations\n\uf0a7New to programming? PRACTICE. PRACTICE? PRACTICE! \n\u25e6can\u2019t passively absorb programming as a skill\n\u25e6download code before lecture and follow along\n\u25e6do MITx finger exercises \n\u25e6don\u2019t be afraid to try out Python commands! \n6\n6.0001 LECTURE 1\nPRACTICE\n7\n6.0001 LECTURE 1\nPROBLEM \nSOLVING\nPROGRAMMING \nSKILL\nKNOWLEDGE \nOF CONCEPTS\nTOPICS\n\uf0a7represent knowledge with data structures\n\uf0a7iteration and recursion as computational metaphors\n\uf0a7abstraction of procedures and data types\n\uf0a7organize and modularize systems using object classes \nand methods\n\uf0a7different classes of algorithms, searching and sorting\n\uf0a7complexity of algorithms\n6.0001 LECTURE 1\n8\nWHAT DOES A COMPUTER DO\n\uf0a7Fundamentally:\n\u25e6performs calculations\na billion calculations per second!\n\u25e6remembers results\n100s of gigabytes of storage!\n\uf0a7What kinds of calculations?\n\u25e6built-in to the language\n\u25e6ones that you define as the programmer\n\uf0a7computers only know what you tell them\n6.0001 LECTURE 1\n9\nTYPES OF KNOWLEDGE\n\uf0a7declarative knowledge is statements of fact. \n\u25e6someone will win a Google \nCardboard before class ends\n\uf0a7imperative knowledge is a recipe or \u201chow-to\u201d.  \n1) Students sign up for raffle\n2) Ana opens her IDE\n3) Ana chooses a random number between 1st and nth responder\n4) Ana finds the number in the responders sheet. Winner!\n6.0001 LECTURE 1\n10\nA NUMERICAL EXAMPLE\n\uf0a7square root of a number x is y such that y*y = x\n\uf0a7recipe for deducing square root of a number x (16)\n1) Start with a guess, g\n2) If g*g is close enough to x, stop and say g is the \nanswer \n3) Otherwise make a new guess by averaging g and x/g\n4) Using the new guess, repeat process until close enough\n6.0001 LECTURE 1\n11\ng\ng*g\nx/g\n(g+x/g)/2\n3\n9\n16/3\n4.17\n4.17\n17.36\n3.837\n4.0035\n4.0035\n16.0277\n3.997\n4.000002\nWHAT IS A RECIPE\n1)\nsequence of simple steps\n2)\nflow of control process that specifies when each \nstep is executed\n3)\na means of determining when to stop\n1+2+3 = an algorithm!\n6.0001 LECTURE 1\n12\nCOMPUTERS ARE MACHINES\n\uf0a7how to capture a recipe in a mechanical process\n\uf0a7fixed program computer\n\u25e6calculator\n\uf0a7stored program computer\n\u25e6machine stores and executes instructions\n6.0001 LECTURE 1\n13\nBASIC MACHINE ARCHITECTURE\n6.0001 LECTURE 1\n14\nMEMORY\nCONTROL \nUNIT\nARITHMETIC \nLOGIC UNIT\nINPUT\nOUTPUT\nprogram counter\ndo primitive ops\nSTORED PROGRAM COMPUTER\n\uf0a7sequence of instructions stored inside computer\n\u25e6built from predefined set of primitive instructions\n1)\narithmetic and logic\n2)\nsimple tests\n3)\nmoving data\n\uf0a7special program (interpreter) executes each \ninstruction in order\n\u25e6use tests to change flow of control through sequence\n\u25e6stop when done\n6.0001 LECTURE 1\n15\nBASIC PRIMITIVES\n\uf0a7Turing showed that you can compute anything using 6 \nprimitives\n\uf0a7modern programming languages have more \nconvenient set of primitives\n\uf0a7can abstract methods to create new primitives\n\uf0a7anything computable in one language is computable in \nany other programming language\n6.0001 LECTURE 1\n16\nCREATING RECIPES\n\uf0a7a programming language provides a set of primitive \noperations\n\uf0a7expressions are complex but legal combinations of \nprimitives in a programming language\n\uf0a7expressions and computations have values and \nmeanings in a programming language\n6.0001 LECTURE 1\n17\nASPECTS OF LANGUAGES\n\uf0a7primitive constructs\n\u25e6English: words\n\u25e6programming language: numbers, strings, simple \noperators\n6.0001 LECTURE 1\n18\nWord Cloud copyright Michael Twardos, All Right Reserved. This content is excluded from our\nCreative Commons license. For more information, see https://ocw.mit.edu/help/faq-fair-use/.\nWord Cloud copyright unknown, All Right Reserved.\nThis content is excluded from our Creative\nCommons license. For more information, see\nhttps://ocw.mit.edu/help/faq-fair-use/.\nASPECTS OF LANGUAGES\n\uf0a7syntax\n\u25e6English: \"cat dog boy\"    \uf0e0not syntactically valid\n\"cat hugs boy\" \uf0e0syntactically valid\n\u25e6programming language: \"hi\"5 \uf0e0not syntactically valid\n3.2*5 \uf0e0syntactically valid\n6.0001 LECTURE 1\n19\nASPECTS OF LANGUAGES\n\uf0a7static semantics is which syntactically valid strings \nhave meaning\n\u25e6English: \"I are hungry\" \uf0e0syntactically valid\nbut static semantic error\n\u25e6programming language: 3.2*5\n\uf0e0syntactically valid\n3+\"hi\" \uf0e0static semantic error\n6.0001 LECTURE 1\n20\nASPECTS OF LANGUAGES\n\uf0a7semantics is the meaning associated with a \nsyntactically correct string of symbols with no static \nsemantic errors\n\u25e6English: can have many meanings \"Flying planes \ncan be dangerous\"\n\u25e6programming languages: have only one meaning but may \nnot be what programmer intended\n6.0001 LECTURE 1\n21\nWHERE THINGS GO WRONG\n\uf0a7syntactic errors\n\u25e6common and easily caught\n\uf0a7static semantic errors\n\u25e6some languages check for these before running program\n\u25e6can cause unpredictable behavior\n\uf0a7no semantic errors but different meaning than what \nprogrammer intended\n\u25e6program crashes, stops running\n\u25e6program runs forever\n\u25e6program gives an answer but different than expected\n6.0001 LECTURE 1\n22\nPYTHON PROGRAMS\n\uf0a7a program is a sequence of definitions and commands\n\u25e6definitions evaluated \n\u25e6commands executed by Python interpreter in a shell\n\uf0a7commands (statements) instruct interpreter to do \nsomething\n\uf0a7can be typed directly in a shell or stored in a file that \nis read into the shell and evaluated\n\u25e6Problem Set 0 will introduce you to these in Anaconda\n6.0001 LECTURE 1\n23\nOBJECTS\n\uf0a7programs manipulate data objects\n\uf0a7objects have a type that defines the kinds of things \nprograms can do to them\n\u25e6Ana is a human so she can walk, speak English, etc.\n\u25e6Chewbacca is a wookie so he can walk, \u201cmwaaarhrhh\u201d, etc.\n\uf0a7objects are\n\u25e6scalar (cannot be subdivided)\n\u25e6non-scalar (have internal structure that can be accessed)\n6.0001 LECTURE 1\n24\nSCALAR OBJECTS\n\uf0a7int \u2013 represent integers, ex. 5\n\uf0a7float \u2013 represent real numbers, ex. 3.27\n\uf0a7bool \u2013 represent Boolean values True and False\n\uf0a7NoneType \u2013 special and has one value, None\n\uf0a7can use type() to see the type of an object\n>>> type(5)\nint\n>>> type(3.0)\nfloat\n6.0001 LECTURE 1\n25\nTYPE CONVERSIONS (CAST)\n\uf0a7can convert object of one type to another\n\uf0a7float(3) converts integer 3 to float 3.0\n\uf0a7int(3.9) truncates float 3.9 to integer 3\n6.0001 LECTURE 1\n26\nPRINTING TO CONSOLE\n\uf0a7to show output from code to a user, use print\ncommand\nIn [11]: 3+2\nOut[11]: 5\nIn [12]: print(3+2)\n5\n6.0001 LECTURE 1\n27\nEXPRESSIONS\n\uf0a7combine objects and operators to form expressions\n\uf0a7an expression has a value, which has a type\n\uf0a7syntax for a simple expression\n<object> <operator> <object>\n6.0001 LECTURE 1\n28\nOPERATORS ON ints and floats\n\uf0a7i+j\n\uf0e0the sum\n\uf0a7i-j\n\uf0e0the difference\n\uf0a7i*j\n\uf0e0the product\n\uf0a7i/j\n\uf0e0division\n\uf0a7i%j\n\uf0e0the remainder when i is divided by j\n\uf0a7i**j \uf0e0i to the power of j\n6.0001 LECTURE 1\n29\nif both are ints, result is int\nif either or both are floats, result is float\nresult is float\nSIMPLE OPERATIONS\n\uf0a7parentheses used to tell Python to do these \noperations first\n\uf0a7operator precedence without parentheses\n\u25e6**\n\u25e6*\n\u25e6/\n\u25e6+ and \u2013 executed left to right, as appear in expression\n6.0001 LECTURE 1\n30\nBINDING VARIABLES AND \nVALUES\n\uf0a7equal sign is an assignment of a value to a variable \nname\npi = 3.14159\npi_approx = 22/7\n\uf0a7value stored in computer memory\n\uf0a7an assignment binds name to value\n\uf0a7retrieve value associated with name or variable by \ninvoking the name, by typing pi\n6.0001 LECTURE 1\n31\nABSTRACTING EXPRESSIONS\n\uf0a7why give names to values of expressions?\n\uf0a7to reuse names instead of values\n\uf0a7easier to change code later\npi = 3.14159\nradius = 2.2\narea = pi*(radius**2)\n6.0001 LECTURE 1\n32\nPROGRAMMING vs MATH\n\uf0a7in programming, you do not \u201csolve for x\u201d\npi = 3.14159\nradius = 2.2\n# area of circle\narea = pi*(radius**2)\nradius = radius+1\n6.0001 LECTURE 1\n33\nCHANGING BINDINGS\n\uf0a7can re-bind variable names using new assignment \nstatements\n\uf0a7previous value may still stored in memory but lost the \nhandle for it\n\uf0a7value for area does not change until you tell the \ncomputer to do the calculation again\n6.0001 LECTURE 1\n34\npi\nradius\narea\n3.14\n2.2\n15.1976\n3.2\npi = 3.14\nradius = 2.2\narea = pi*(radius**2)\nradius = radius+1\nMIT OpenCourseWare\nhttps://ocw.mit.edu\n6.0001 Introduction to Computer Science and Programming in Python\nFall  2016\nFor information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms."
  },
  {
    "title": "Expressions",
    "content": "WELCOME!\n(download slides and .py files and follow along!)\n6.0001 LECTURE 1\n1\n6.0001 LECTURE 1\nTODAY\n\uf0a7course info\n\uf0a7what is computation\n\uf0a7python basics\n\uf0a7mathematical operations\n\uf0a7python variables and types\n\uf0a7NOTE: slides and code files up before each lecture\no highly encourage you to download them before lecture\no take notes and run code files when I do\no bring computers to answer in-class practice exercises!\n2\n6.0001 LECTURE 1\nCOURSE INFO\n\uf0a7Grading\n\u25e6approx. 20%  Quiz\n\u25e6approx. 40%  Final \n\u25e6approx. 30%  Problem Sets \n\u25e6approx. 10%  MITx Finger Exercises\n3\n6.0001 LECTURE 1\nCOURSE POLICIES\n\uf0a7Collaboration\n\u25e6may collaborate with anyone\n\u25e6required to write code independently and write names of \nall collaborators on submission\n\u25e6we will be running a code similarity program on all psets\n\uf0a7Extensions\n\u25e6no extensions\n\u25e6late days, see course website for details\n\u25e6drop and roll weight of max two psets in final exam grade\n\u25e6should be EMERGENCY use only\n4\n6.0001 LECTURE 1\nRECITATIONS\n\uf0a7not mandatory\n\uf0a7two flavors\n1) Lecture review: review lecture material \no if you missed lecture \no if you need a different take on the same concepts\n2) Problem solving: teach you how to solve programming \nproblems\no useful if you don\u2019t know how to set up pseudocode from pset words \no we show a couple of harder questions\no walk you through how to approach solving the problem\no brainstorm code solution along with the recitation instructor\no will post solutions after\n6.0001 LECTURE 1\n5\nFAST PACED COURSE\n\uf0a7Position yourself to succeed!\n\u25e6read psets when they come out and come back to them later\n\u25e6use late days in emergency situations\n\uf0a7New to programming? PRACTICE. PRACTICE? PRACTICE! \n\u25e6can\u2019t passively absorb programming as a skill\n\u25e6download code before lecture and follow along\n\u25e6do MITx finger exercises \n\u25e6don\u2019t be afraid to try out Python commands! \n6\n6.0001 LECTURE 1\nPRACTICE\n7\n6.0001 LECTURE 1\nPROBLEM \nSOLVING\nPROGRAMMING \nSKILL\nKNOWLEDGE \nOF CONCEPTS\nTOPICS\n\uf0a7represent knowledge with data structures\n\uf0a7iteration and recursion as computational metaphors\n\uf0a7abstraction of procedures and data types\n\uf0a7organize and modularize systems using object classes \nand methods\n\uf0a7different classes of algorithms, searching and sorting\n\uf0a7complexity of algorithms\n6.0001 LECTURE 1\n8\nWHAT DOES A COMPUTER DO\n\uf0a7Fundamentally:\n\u25e6performs calculations\na billion calculations per second!\n\u25e6remembers results\n100s of gigabytes of storage!\n\uf0a7What kinds of calculations?\n\u25e6built-in to the language\n\u25e6ones that you define as the programmer\n\uf0a7computers only know what you tell them\n6.0001 LECTURE 1\n9\nTYPES OF KNOWLEDGE\n\uf0a7declarative knowledge is statements of fact. \n\u25e6someone will win a Google \nCardboard before class ends\n\uf0a7imperative knowledge is a recipe or \u201chow-to\u201d.  \n1) Students sign up for raffle\n2) Ana opens her IDE\n3) Ana chooses a random number between 1st and nth responder\n4) Ana finds the number in the responders sheet. Winner!\n6.0001 LECTURE 1\n10\nA NUMERICAL EXAMPLE\n\uf0a7square root of a number x is y such that y*y = x\n\uf0a7recipe for deducing square root of a number x (16)\n1) Start with a guess, g\n2) If g*g is close enough to x, stop and say g is the \nanswer \n3) Otherwise make a new guess by averaging g and x/g\n4) Using the new guess, repeat process until close enough\n6.0001 LECTURE 1\n11\ng\ng*g\nx/g\n(g+x/g)/2\n3\n9\n16/3\n4.17\n4.17\n17.36\n3.837\n4.0035\n4.0035\n16.0277\n3.997\n4.000002\nWHAT IS A RECIPE\n1)\nsequence of simple steps\n2)\nflow of control process that specifies when each \nstep is executed\n3)\na means of determining when to stop\n1+2+3 = an algorithm!\n6.0001 LECTURE 1\n12\nCOMPUTERS ARE MACHINES\n\uf0a7how to capture a recipe in a mechanical process\n\uf0a7fixed program computer\n\u25e6calculator\n\uf0a7stored program computer\n\u25e6machine stores and executes instructions\n6.0001 LECTURE 1\n13\nBASIC MACHINE ARCHITECTURE\n6.0001 LECTURE 1\n14\nMEMORY\nCONTROL \nUNIT\nARITHMETIC \nLOGIC UNIT\nINPUT\nOUTPUT\nprogram counter\ndo primitive ops\nSTORED PROGRAM COMPUTER\n\uf0a7sequence of instructions stored inside computer\n\u25e6built from predefined set of primitive instructions\n1)\narithmetic and logic\n2)\nsimple tests\n3)\nmoving data\n\uf0a7special program (interpreter) executes each \ninstruction in order\n\u25e6use tests to change flow of control through sequence\n\u25e6stop when done\n6.0001 LECTURE 1\n15\nBASIC PRIMITIVES\n\uf0a7Turing showed that you can compute anything using 6 \nprimitives\n\uf0a7modern programming languages have more \nconvenient set of primitives\n\uf0a7can abstract methods to create new primitives\n\uf0a7anything computable in one language is computable in \nany other programming language\n6.0001 LECTURE 1\n16\nCREATING RECIPES\n\uf0a7a programming language provides a set of primitive \noperations\n\uf0a7expressions are complex but legal combinations of \nprimitives in a programming language\n\uf0a7expressions and computations have values and \nmeanings in a programming language\n6.0001 LECTURE 1\n17\nASPECTS OF LANGUAGES\n\uf0a7primitive constructs\n\u25e6English: words\n\u25e6programming language: numbers, strings, simple \noperators\n6.0001 LECTURE 1\n18\nWord Cloud copyright Michael Twardos, All Right Reserved. This content is excluded from our\nCreative Commons license. For more information, see https://ocw.mit.edu/help/faq-fair-use/.\nWord Cloud copyright unknown, All Right Reserved.\nThis content is excluded from our Creative\nCommons license. For more information, see\nhttps://ocw.mit.edu/help/faq-fair-use/.\nASPECTS OF LANGUAGES\n\uf0a7syntax\n\u25e6English: \"cat dog boy\"    \uf0e0not syntactically valid\n\"cat hugs boy\" \uf0e0syntactically valid\n\u25e6programming language: \"hi\"5 \uf0e0not syntactically valid\n3.2*5 \uf0e0syntactically valid\n6.0001 LECTURE 1\n19\nASPECTS OF LANGUAGES\n\uf0a7static semantics is which syntactically valid strings \nhave meaning\n\u25e6English: \"I are hungry\" \uf0e0syntactically valid\nbut static semantic error\n\u25e6programming language: 3.2*5\n\uf0e0syntactically valid\n3+\"hi\" \uf0e0static semantic error\n6.0001 LECTURE 1\n20\nASPECTS OF LANGUAGES\n\uf0a7semantics is the meaning associated with a \nsyntactically correct string of symbols with no static \nsemantic errors\n\u25e6English: can have many meanings \"Flying planes \ncan be dangerous\"\n\u25e6programming languages: have only one meaning but may \nnot be what programmer intended\n6.0001 LECTURE 1\n21\nWHERE THINGS GO WRONG\n\uf0a7syntactic errors\n\u25e6common and easily caught\n\uf0a7static semantic errors\n\u25e6some languages check for these before running program\n\u25e6can cause unpredictable behavior\n\uf0a7no semantic errors but different meaning than what \nprogrammer intended\n\u25e6program crashes, stops running\n\u25e6program runs forever\n\u25e6program gives an answer but different than expected\n6.0001 LECTURE 1\n22\nPYTHON PROGRAMS\n\uf0a7a program is a sequence of definitions and commands\n\u25e6definitions evaluated \n\u25e6commands executed by Python interpreter in a shell\n\uf0a7commands (statements) instruct interpreter to do \nsomething\n\uf0a7can be typed directly in a shell or stored in a file that \nis read into the shell and evaluated\n\u25e6Problem Set 0 will introduce you to these in Anaconda\n6.0001 LECTURE 1\n23\nOBJECTS\n\uf0a7programs manipulate data objects\n\uf0a7objects have a type that defines the kinds of things \nprograms can do to them\n\u25e6Ana is a human so she can walk, speak English, etc.\n\u25e6Chewbacca is a wookie so he can walk, \u201cmwaaarhrhh\u201d, etc.\n\uf0a7objects are\n\u25e6scalar (cannot be subdivided)\n\u25e6non-scalar (have internal structure that can be accessed)\n6.0001 LECTURE 1\n24\nSCALAR OBJECTS\n\uf0a7int \u2013 represent integers, ex. 5\n\uf0a7float \u2013 represent real numbers, ex. 3.27\n\uf0a7bool \u2013 represent Boolean values True and False\n\uf0a7NoneType \u2013 special and has one value, None\n\uf0a7can use type() to see the type of an object\n>>> type(5)\nint\n>>> type(3.0)\nfloat\n6.0001 LECTURE 1\n25\nTYPE CONVERSIONS (CAST)\n\uf0a7can convert object of one type to another\n\uf0a7float(3) converts integer 3 to float 3.0\n\uf0a7int(3.9) truncates float 3.9 to integer 3\n6.0001 LECTURE 1\n26\nPRINTING TO CONSOLE\n\uf0a7to show output from code to a user, use print\ncommand\nIn [11]: 3+2\nOut[11]: 5\nIn [12]: print(3+2)\n5\n6.0001 LECTURE 1\n27\nEXPRESSIONS\n\uf0a7combine objects and operators to form expressions\n\uf0a7an expression has a value, which has a type\n\uf0a7syntax for a simple expression\n<object> <operator> <object>\n6.0001 LECTURE 1\n28\nOPERATORS ON ints and floats\n\uf0a7i+j\n\uf0e0the sum\n\uf0a7i-j\n\uf0e0the difference\n\uf0a7i*j\n\uf0e0the product\n\uf0a7i/j\n\uf0e0division\n\uf0a7i%j\n\uf0e0the remainder when i is divided by j\n\uf0a7i**j \uf0e0i to the power of j\n6.0001 LECTURE 1\n29\nif both are ints, result is int\nif either or both are floats, result is float\nresult is float\nSIMPLE OPERATIONS\n\uf0a7parentheses used to tell Python to do these \noperations first\n\uf0a7operator precedence without parentheses\n\u25e6**\n\u25e6*\n\u25e6/\n\u25e6+ and \u2013 executed left to right, as appear in expression\n6.0001 LECTURE 1\n30\nBINDING VARIABLES AND \nVALUES\n\uf0a7equal sign is an assignment of a value to a variable \nname\npi = 3.14159\npi_approx = 22/7\n\uf0a7value stored in computer memory\n\uf0a7an assignment binds name to value\n\uf0a7retrieve value associated with name or variable by \ninvoking the name, by typing pi\n6.0001 LECTURE 1\n31\nABSTRACTING EXPRESSIONS\n\uf0a7why give names to values of expressions?\n\uf0a7to reuse names instead of values\n\uf0a7easier to change code later\npi = 3.14159\nradius = 2.2\narea = pi*(radius**2)\n6.0001 LECTURE 1\n32\nPROGRAMMING vs MATH\n\uf0a7in programming, you do not \u201csolve for x\u201d\npi = 3.14159\nradius = 2.2\n# area of circle\narea = pi*(radius**2)\nradius = radius+1\n6.0001 LECTURE 1\n33\nCHANGING BINDINGS\n\uf0a7can re-bind variable names using new assignment \nstatements\n\uf0a7previous value may still stored in memory but lost the \nhandle for it\n\uf0a7value for area does not change until you tell the \ncomputer to do the calculation again\n6.0001 LECTURE 1\n34\npi\nradius\narea\n3.14\n2.2\n15.1976\n3.2\npi = 3.14\nradius = 2.2\narea = pi*(radius**2)\nradius = radius+1\nMIT OpenCourseWare\nhttps://ocw.mit.edu\n6.0001 Introduction to Computer Science and Programming in Python\nFall  2016\nFor information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms."
  },
  {
    "title": "Computation",
    "content": "WELCOME!\n(download slides and .py files and follow along!)\n6.0001 LECTURE 1\n1\n6.0001 LECTURE 1\nTODAY\n\uf0a7course info\n\uf0a7what is computation\n\uf0a7python basics\n\uf0a7mathematical operations\n\uf0a7python variables and types\n\uf0a7NOTE: slides and code files up before each lecture\no highly encourage you to download them before lecture\no take notes and run code files when I do\no bring computers to answer in-class practice exercises!\n2\n6.0001 LECTURE 1\nCOURSE INFO\n\uf0a7Grading\n\u25e6approx. 20%  Quiz\n\u25e6approx. 40%  Final \n\u25e6approx. 30%  Problem Sets \n\u25e6approx. 10%  MITx Finger Exercises\n3\n6.0001 LECTURE 1\nCOURSE POLICIES\n\uf0a7Collaboration\n\u25e6may collaborate with anyone\n\u25e6required to write code independently and write names of \nall collaborators on submission\n\u25e6we will be running a code similarity program on all psets\n\uf0a7Extensions\n\u25e6no extensions\n\u25e6late days, see course website for details\n\u25e6drop and roll weight of max two psets in final exam grade\n\u25e6should be EMERGENCY use only\n4\n6.0001 LECTURE 1\nRECITATIONS\n\uf0a7not mandatory\n\uf0a7two flavors\n1) Lecture review: review lecture material \no if you missed lecture \no if you need a different take on the same concepts\n2) Problem solving: teach you how to solve programming \nproblems\no useful if you don\u2019t know how to set up pseudocode from pset words \no we show a couple of harder questions\no walk you through how to approach solving the problem\no brainstorm code solution along with the recitation instructor\no will post solutions after\n6.0001 LECTURE 1\n5\nFAST PACED COURSE\n\uf0a7Position yourself to succeed!\n\u25e6read psets when they come out and come back to them later\n\u25e6use late days in emergency situations\n\uf0a7New to programming? PRACTICE. PRACTICE? PRACTICE! \n\u25e6can\u2019t passively absorb programming as a skill\n\u25e6download code before lecture and follow along\n\u25e6do MITx finger exercises \n\u25e6don\u2019t be afraid to try out Python commands! \n6\n6.0001 LECTURE 1\nPRACTICE\n7\n6.0001 LECTURE 1\nPROBLEM \nSOLVING\nPROGRAMMING \nSKILL\nKNOWLEDGE \nOF CONCEPTS\nTOPICS\n\uf0a7represent knowledge with data structures\n\uf0a7iteration and recursion as computational metaphors\n\uf0a7abstraction of procedures and data types\n\uf0a7organize and modularize systems using object classes \nand methods\n\uf0a7different classes of algorithms, searching and sorting\n\uf0a7complexity of algorithms\n6.0001 LECTURE 1\n8\nWHAT DOES A COMPUTER DO\n\uf0a7Fundamentally:\n\u25e6performs calculations\na billion calculations per second!\n\u25e6remembers results\n100s of gigabytes of storage!\n\uf0a7What kinds of calculations?\n\u25e6built-in to the language\n\u25e6ones that you define as the programmer\n\uf0a7computers only know what you tell them\n6.0001 LECTURE 1\n9\nTYPES OF KNOWLEDGE\n\uf0a7declarative knowledge is statements of fact. \n\u25e6someone will win a Google \nCardboard before class ends\n\uf0a7imperative knowledge is a recipe or \u201chow-to\u201d.  \n1) Students sign up for raffle\n2) Ana opens her IDE\n3) Ana chooses a random number between 1st and nth responder\n4) Ana finds the number in the responders sheet. Winner!\n6.0001 LECTURE 1\n10\nA NUMERICAL EXAMPLE\n\uf0a7square root of a number x is y such that y*y = x\n\uf0a7recipe for deducing square root of a number x (16)\n1) Start with a guess, g\n2) If g*g is close enough to x, stop and say g is the \nanswer \n3) Otherwise make a new guess by averaging g and x/g\n4) Using the new guess, repeat process until close enough\n6.0001 LECTURE 1\n11\ng\ng*g\nx/g\n(g+x/g)/2\n3\n9\n16/3\n4.17\n4.17\n17.36\n3.837\n4.0035\n4.0035\n16.0277\n3.997\n4.000002\nWHAT IS A RECIPE\n1)\nsequence of simple steps\n2)\nflow of control process that specifies when each \nstep is executed\n3)\na means of determining when to stop\n1+2+3 = an algorithm!\n6.0001 LECTURE 1\n12\nCOMPUTERS ARE MACHINES\n\uf0a7how to capture a recipe in a mechanical process\n\uf0a7fixed program computer\n\u25e6calculator\n\uf0a7stored program computer\n\u25e6machine stores and executes instructions\n6.0001 LECTURE 1\n13\nBASIC MACHINE ARCHITECTURE\n6.0001 LECTURE 1\n14\nMEMORY\nCONTROL \nUNIT\nARITHMETIC \nLOGIC UNIT\nINPUT\nOUTPUT\nprogram counter\ndo primitive ops\nSTORED PROGRAM COMPUTER\n\uf0a7sequence of instructions stored inside computer\n\u25e6built from predefined set of primitive instructions\n1)\narithmetic and logic\n2)\nsimple tests\n3)\nmoving data\n\uf0a7special program (interpreter) executes each \ninstruction in order\n\u25e6use tests to change flow of control through sequence\n\u25e6stop when done\n6.0001 LECTURE 1\n15\nBASIC PRIMITIVES\n\uf0a7Turing showed that you can compute anything using 6 \nprimitives\n\uf0a7modern programming languages have more \nconvenient set of primitives\n\uf0a7can abstract methods to create new primitives\n\uf0a7anything computable in one language is computable in \nany other programming language\n6.0001 LECTURE 1\n16\nCREATING RECIPES\n\uf0a7a programming language provides a set of primitive \noperations\n\uf0a7expressions are complex but legal combinations of \nprimitives in a programming language\n\uf0a7expressions and computations have values and \nmeanings in a programming language\n6.0001 LECTURE 1\n17\nASPECTS OF LANGUAGES\n\uf0a7primitive constructs\n\u25e6English: words\n\u25e6programming language: numbers, strings, simple \noperators\n6.0001 LECTURE 1\n18\nWord Cloud copyright Michael Twardos, All Right Reserved. This content is excluded from our\nCreative Commons license. For more information, see https://ocw.mit.edu/help/faq-fair-use/.\nWord Cloud copyright unknown, All Right Reserved.\nThis content is excluded from our Creative\nCommons license. For more information, see\nhttps://ocw.mit.edu/help/faq-fair-use/.\nASPECTS OF LANGUAGES\n\uf0a7syntax\n\u25e6English: \"cat dog boy\"    \uf0e0not syntactically valid\n\"cat hugs boy\" \uf0e0syntactically valid\n\u25e6programming language: \"hi\"5 \uf0e0not syntactically valid\n3.2*5 \uf0e0syntactically valid\n6.0001 LECTURE 1\n19\nASPECTS OF LANGUAGES\n\uf0a7static semantics is which syntactically valid strings \nhave meaning\n\u25e6English: \"I are hungry\" \uf0e0syntactically valid\nbut static semantic error\n\u25e6programming language: 3.2*5\n\uf0e0syntactically valid\n3+\"hi\" \uf0e0static semantic error\n6.0001 LECTURE 1\n20\nASPECTS OF LANGUAGES\n\uf0a7semantics is the meaning associated with a \nsyntactically correct string of symbols with no static \nsemantic errors\n\u25e6English: can have many meanings \"Flying planes \ncan be dangerous\"\n\u25e6programming languages: have only one meaning but may \nnot be what programmer intended\n6.0001 LECTURE 1\n21\nWHERE THINGS GO WRONG\n\uf0a7syntactic errors\n\u25e6common and easily caught\n\uf0a7static semantic errors\n\u25e6some languages check for these before running program\n\u25e6can cause unpredictable behavior\n\uf0a7no semantic errors but different meaning than what \nprogrammer intended\n\u25e6program crashes, stops running\n\u25e6program runs forever\n\u25e6program gives an answer but different than expected\n6.0001 LECTURE 1\n22\nPYTHON PROGRAMS\n\uf0a7a program is a sequence of definitions and commands\n\u25e6definitions evaluated \n\u25e6commands executed by Python interpreter in a shell\n\uf0a7commands (statements) instruct interpreter to do \nsomething\n\uf0a7can be typed directly in a shell or stored in a file that \nis read into the shell and evaluated\n\u25e6Problem Set 0 will introduce you to these in Anaconda\n6.0001 LECTURE 1\n23\nOBJECTS\n\uf0a7programs manipulate data objects\n\uf0a7objects have a type that defines the kinds of things \nprograms can do to them\n\u25e6Ana is a human so she can walk, speak English, etc.\n\u25e6Chewbacca is a wookie so he can walk, \u201cmwaaarhrhh\u201d, etc.\n\uf0a7objects are\n\u25e6scalar (cannot be subdivided)\n\u25e6non-scalar (have internal structure that can be accessed)\n6.0001 LECTURE 1\n24\nSCALAR OBJECTS\n\uf0a7int \u2013 represent integers, ex. 5\n\uf0a7float \u2013 represent real numbers, ex. 3.27\n\uf0a7bool \u2013 represent Boolean values True and False\n\uf0a7NoneType \u2013 special and has one value, None\n\uf0a7can use type() to see the type of an object\n>>> type(5)\nint\n>>> type(3.0)\nfloat\n6.0001 LECTURE 1\n25\nTYPE CONVERSIONS (CAST)\n\uf0a7can convert object of one type to another\n\uf0a7float(3) converts integer 3 to float 3.0\n\uf0a7int(3.9) truncates float 3.9 to integer 3\n6.0001 LECTURE 1\n26\nPRINTING TO CONSOLE\n\uf0a7to show output from code to a user, use print\ncommand\nIn [11]: 3+2\nOut[11]: 5\nIn [12]: print(3+2)\n5\n6.0001 LECTURE 1\n27\nEXPRESSIONS\n\uf0a7combine objects and operators to form expressions\n\uf0a7an expression has a value, which has a type\n\uf0a7syntax for a simple expression\n<object> <operator> <object>\n6.0001 LECTURE 1\n28\nOPERATORS ON ints and floats\n\uf0a7i+j\n\uf0e0the sum\n\uf0a7i-j\n\uf0e0the difference\n\uf0a7i*j\n\uf0e0the product\n\uf0a7i/j\n\uf0e0division\n\uf0a7i%j\n\uf0e0the remainder when i is divided by j\n\uf0a7i**j \uf0e0i to the power of j\n6.0001 LECTURE 1\n29\nif both are ints, result is int\nif either or both are floats, result is float\nresult is float\nSIMPLE OPERATIONS\n\uf0a7parentheses used to tell Python to do these \noperations first\n\uf0a7operator precedence without parentheses\n\u25e6**\n\u25e6*\n\u25e6/\n\u25e6+ and \u2013 executed left to right, as appear in expression\n6.0001 LECTURE 1\n30\nBINDING VARIABLES AND \nVALUES\n\uf0a7equal sign is an assignment of a value to a variable \nname\npi = 3.14159\npi_approx = 22/7\n\uf0a7value stored in computer memory\n\uf0a7an assignment binds name to value\n\uf0a7retrieve value associated with name or variable by \ninvoking the name, by typing pi\n6.0001 LECTURE 1\n31\nABSTRACTING EXPRESSIONS\n\uf0a7why give names to values of expressions?\n\uf0a7to reuse names instead of values\n\uf0a7easier to change code later\npi = 3.14159\nradius = 2.2\narea = pi*(radius**2)\n6.0001 LECTURE 1\n32\nPROGRAMMING vs MATH\n\uf0a7in programming, you do not \u201csolve for x\u201d\npi = 3.14159\nradius = 2.2\n# area of circle\narea = pi*(radius**2)\nradius = radius+1\n6.0001 LECTURE 1\n33\nCHANGING BINDINGS\n\uf0a7can re-bind variable names using new assignment \nstatements\n\uf0a7previous value may still stored in memory but lost the \nhandle for it\n\uf0a7value for area does not change until you tell the \ncomputer to do the calculation again\n6.0001 LECTURE 1\n34\npi\nradius\narea\n3.14\n2.2\n15.1976\n3.2\npi = 3.14\nradius = 2.2\narea = pi*(radius**2)\nradius = radius+1\nMIT OpenCourseWare\nhttps://ocw.mit.edu\n6.0001 Introduction to Computer Science and Programming in Python\nFall  2016\nFor information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms."
  }
]