{
  "title": "algorithms",
  "content": "square root of a number x is y such that y*y = x\nrecipe for deducing square root of a number x (16)\n1)Start with a guess, g\n2)If g*gis close enough to x, stop and say g is the \nanswer \n3)Otherwise make a new guess by averaging g and x/g\n4)Using the new guess, repeatprocess until close enough\n6.0001 LECTURE 1\n11\ngg*gx/g(g+x/g)/2\n3916/34.17\n4.1717.363.8374.0035\n4.003516.02773.9974.000002\n\nWHAT IS A RECIPE\n1)sequence of simple steps\n2)flow of controlprocess that specifies when each \nstep is executed\n3)a means of determining when to stop\n1+2+3 = an algorithm!\n6.0001 LECTURE 1\n12\n\nCOMPUTERS ARE MACHINES\nhow to capture a recipe in a mechanical process\nfixed program computer\n◦calculator\nstored program computer\n◦machine stores and executes instructions\n6.0001 LECTURE 1\n13\n\nBASIC MACHINE ARCHITECTURE\n6.0001 LECTURE 1\n14\nMEMORY\nCONTROL \nUNIT\nARITHMETIC \nLOGIC UNIT\nINPUTOUTPUT\nprogram counterdo primitive ops\n\nSTORED PROGRAM COMPUTER\nsequence of instructions stored inside computer\n◦built from predefined set of primitive instructions\n1)arithmetic and logic\n2)simple tests\n3)moving data\nspecial program (interpreter) executes each \ninstruction in order\n◦use tests to change flow of control through sequence\n◦stop when done\n6.0001 LECTURE 1\n15\n\nBASIC PRIMITIVES\nTuring showed that you can compute anything using 6 \nprimitives\nmodern programming languages have more \nconvenient set of primitives\ncan abstract methods to createnew primitives\nanything computable in one language is computable in \nany other programming language\n6.0001 LECTURE 1\n16\n\nCREATING RECIPES\na programming language provides a set of primitive \noperations\nexpressionsare complex but legal combinations of \nprimitives in a programming language\nexpressions and computations have valuesand \nmeanings in a programming language\n6.0001 LECTURE 1\n17\n\nASPECTS OF LANGUAGES\nprimitive constructs\n◦English: words\n◦programming language: numbers, strings, simple \noperators\n6.0001 LECTURE 1\n18\nWord Cloud copyright Michael Twardos, All Right Reserved. This content is excluded from our\nCreative Commons license. For more information, see https://ocw.mit.edu/help/faq-fair-use/.\nWord Cloud copyright unknown, All Right Reserved.\nThis content is excluded from our Creative\nCommons\n license. For more information, see\nhttps://ocw.mit.edu/help/faq-fair-use/.\n\nASPECTS OF LANGUAGES\nsyntax\n◦English: \"cat dog boy\"    not syntactically valid\n\"cat hugs boy\"syntactically valid\n◦programming language: \"hi\"5not syntactically valid\n3.2*5syntactically valid\n6.0001 LECTURE 1\n19\n\nASPECTS OF LANGUAGES\nstatic semanticsis which syntactically valid strings \nhave meaning\n◦English: \"I are hungry\"syntactically valid\nbut static semantic error\n◦programming language: 3.2*5syntactically valid\n3+\"hi\"static semantic error\n6.0001 LECTURE 1\n20\n\nASPECTS OF LANGUAGES\nsemanticsis the meaning associated with a \nsyntactically correct string of symbols with no static \nsemantic errors\n◦English: can have many meanings \"Flying planes \ncan be dangerous\"\n◦programming languages: have only one meaning but may \nnot be what programmer intended\n6.0001 LECTURE 1\n21\n\nWHERE THINGS GO WRONG\nsyntactic errors\n◦common and easily caught\nstatic semantic errors\n◦some languages check for these before running program\n◦can cause unpredictable behavior\nno semantic errors but differentmeaning than what \nprogrammer intended\n◦program crashes, stops running\n◦program runs forever\n◦program gives an answer but different than expected\n6.0001 LECTURE 1\n22\n\nPYTHON PROGRAMS\na programis a sequence of definitions and commands\n◦definitions evaluated \n◦commands executedby Python interpreter in a shell\ncommands(statements) instruct interpreter to do \nsomething\ncan be typed directly in a shellor stored in a filethat \nis read into the shell and evaluated\n◦Problem Set 0 will introduce you to these in Anaconda\n6.0001 LECTURE 1\n23\n\nOBJECTS\nprograms manipulate data objects\nobjects have a typethat defines the kinds of things \nprograms can do to them\n◦Ana is a human so she can walk, speak English, etc.\n◦Chewbacca is a wookieso he canwalk, “mwaaarhrhh”, etc.\nobjects are\n◦scalar (cannot be subdivided)\n◦non-scalar (have internal structure that can be accessed)\n6.0001 LECTURE 1\n24\n\nSCALAR OBJECTS\nint–represent integers, ex. 5\nfloat –represent real numbers, ex. 3.27\nbool –represent Booleanvalues Trueand False\nNoneType–specialand has one value, None\ncan use type() to see the type of an object\n>>> type(5)\nint\n>>> type(3.0)\nfloat\n6.0001 LECTURE 1\n25\n\nTYPE CONVERSIONS (CAST)\ncan convert object of one type to another\nfloat(3)converts integer 3 to float 3.0\nint(3.9)truncates float 3.9to integer 3\n6.0001 LECTURE 1\n26\n\nPRINTING TO CONSOLE\nto show output from code to a user, use print\ncommand\nIn [11]: 3+2\nOut[11]: 5\nIn [12]: print(3+2)\n5\n6.0001 LECTURE 1\n27\n\nEXPRESSIONS\ncombine objects and operators to form expressions\nan expression has a value, which has a type\nsyntax for a simple expression\n<object> <operator> <object>\n6.0001 LECTURE 1\n28\n\nOPERATORS ON intsand floats\ni+jthe sum\ni-jthe difference\ni*jthe product\ni/jdivision\ni%jthe remainderwhen iis divided by j\ni**jito the powerof j\n6.0001 LECTURE 1\n29\nif both are ints, result is int\nif either or both are floats, result is float\nresult is float\n\nSIMPLE OPERATIONS\nparentheses used to tell Python to do these \noperations first\noperator precedence without parentheses\n◦**\n◦*\n◦/\n◦+ and –executed left to right, as appear in expression\n6.0001 LECTURE 1\n30\n\nBINDING VARIABLES AND \nVALUES\nequal sign is an assignmentof a value to a variable \nname\npi = 3.14159\npi_approx= 22/7\nvalue stored in computer memory\nan assignment binds name to value\nretrieve value associated with name or variable by \ninvoking the name, by typing pi\n6.0001 LECTURE 1\n31\n\nABSTRACTING EXPRESSIONS\nwhy give names to values of expressions?\nto reuse names instead of values\neasier to change code later\npi = 3.14159\nradius = 2.2\narea = pi*(radius**2)\n6.0001 LECTURE 1\n32\n\nPROGRAMMING vs MATH\nin programming, you do not “solve for x”\npi = 3.14159\nradius = 2.2\n# area of circle\narea = pi*(radius**2)\nradius = radius+1\n6.0001 LECTURE 1\n33\n\nCHANGING BINDINGS\ncan re-bindvariable names using new assignment \nstatements\nprevious value may still stored in memory but lost the \nhandle for it\nvalue for area does not change until you tell the \ncomputer to do the calculation again\n6.0001 LECTURE 1\n34\npi\nradius\narea\n3.14\n2.2\n15.1976\n3.2\npi = 3.14\nradius = 2.2\narea = pi*(radius**2)\nradius = radius+1\n\nMIT OpenCourseWare\nhttps://ocw.mit.edu\n6.0001 Introduction to Computer Science and Programming in Python\nFall  2016\nFor information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms."
}