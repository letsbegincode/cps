{
  "title": "approximation",
  "lecture": "03",
  "content": "approximate solutions\nbisection method\n6.0001 LECTURE 3\n3\n\nSTRINGS\nthink of as a sequenceof case sensitive characters\ncan compare strings with ==, >, < etc.\nlen()is a function used to retrieve the lengthof the \nstring in the parentheses\ns = \"abc\"\nlen(s) evaluates to 3\n6.0001 LECTURE 3\n4\n\nSTRINGS\nsquare brackets used to perform indexinginto a string \nto get the value at a certain index/position\ns = \"abc\"\ns[0] evaluates to \"a\"\ns[1] evaluates to \"b\"\ns[2] evaluates to \"c\"\ns[3] trying to index out of bounds, error\ns[-1] evaluates to \"c\"\ns[-2] evaluates to \"b\"\ns[-3] evaluates to \"a\"\n6.0001 LECTURE 3\n5\nindex:   0  1 2     indexing always starts at 0\nindex:   -3 -2 -1    last element always at index -1\n\nSTRINGS\ncan slicestrings using [start:stop:step]\nif give two numbers, [start:stop], step=1by default\nyou can also omit numbers and leave just colons\n6.0001 LECTURE 3\n6\ns = \"abcdefgh\"\ns[3:6]evaluates to \"def\", same ass[3:6:1]\ns[3:6:2]evaluates to \"df\"\ns[::]evaluates to \"abcdefgh\", same as s[0:len(s):1]\ns[::-1]evaluates to \"hgfedbca\", same as s[-1:-(len(s)+1):-1]\ns[4:1:-2]evaluates to \"ec\"\n\nSTRINGS\nstrings are “immutable” –cannot be modified \ns = \"hello\"\ns[0] = 'y' gives an error\ns = 'y'+s[1:len(s)] is allowed,\ns bound to new object\n6.0001 LECTURE 3\n7\ns\n\"hello\"\n\"yello\"\n\nfor LOOPS RECAP\nforloops have a loop variable that iterates over a set of \nvalues\nfor varin range(4):   variterates over values 0,1,2,3\n<expressions>expressions inside loop executed \nwith each value for var\nfor varin range(4,6): variterates over values 4,5\n<expressions>\nrangeis a way to iterate over numbers, but a for loop \nvariable can iterate over any set of values, not just numbers!\n6.0001 LECTURE 3\n8\n\nSTRINGS AND LOOPS\nthese two code snippets do the same thing\nbottom one is more “pythonic” \ns = \"abcdefgh\"\nfor index in range(len(s)):\nif s[index] == 'i' or s[index] == 'u':\nprint(\"There is an ior u\")\nfor char in s:\nif char == 'i' or char == 'u':\nprint(\"There is an ior u\")\n6.0001 LECTURE 3\n9\n\nCODE EXAMPLE: \nROBOT CHEERLEADERS\nan_letters= \"aefhilmnorsxAEFHILMNORSX\"\nword = input(\"I will cheer for you! Enter a word: \")\ntimes = int(input(\"Enthusiasm level (1-10): \"))\ni= 0\nwhile i< len(word):\nchar = word[i]\nif char in an_letters:\nprint(\"Give me an \" + char + \"! \" + char)\nelse:\nprint(\"Give me a  \" + char + \"! \" + char)\ni+= 1\nprint(\"What does that spell?\")\nfor iin range(times):\nprint(word, \"!!!\")\n6.0001 LECTURE 3\n10\nfor char in word:\n\nEXERCISE\ns1 = \"mitu rock\"\ns2 = \"irule mit\"\nif len(s1) == len(s2):\nfor char1 in s1:\nfor char2 in s2:\nif char1 == char2:\nprint(\"common letter\")\nbreak\n6.0001 LECTURE 3\n11\n\nGUESS-AND-CHECK\nthe process below also called exhaustive enumeration\ngiven a problem...\nyou are able to guess a valuefor solution\nyou are able to check if the solution is correct\nkeep guessing until find solution or guessed all values\n6.0001 LECTURE 3\n12\n\nGUESS-AND-CHECK \n–cube  root\ncube = 8\nfor guess in range(cube+1):\nif guess**3 == cube:\nprint(\"Cube root of\", cube, \"is\", guess)\n6.0001 LECTURE 3\n13\n\nGUESS-AND-CHECK \n–cube  root\ncube = 8\nfor guess in range(abs(cube)+1):\nif guess**3 >= abs(cube):\nbreak\nif guess**3 != abs(cube):\nprint(cube, 'is not a perfect cube')\nelse:\nif cube < 0:\nguess = -guess\nprint('Cube root of '+str(cube)+' is '+str(guess))\n6.0001 LECTURE 3\n14\n\nAPPROXIMATE SOLUTIONS\ngood enough solution\nstart with a guess and increment by some small value\nkeep guessing if |guess\n3\n-cube| >= epsilon\nfor some small epsilon\ndecreasing increment size slower program\nincreasing epsilon less accurate answer\n6.0001 LECTURE 3\n15\n\nAPPROXIMATE SOLUTION \n–cube root\ncube = 27\nepsilon = 0.01\nguess = 0.0\nincrement = 0.0001\nnum_guesses= 0\nwhile abs(guess**3 -cube) >= epsilon:\nguess += increment\nnum_guesses+= 1\nprint('num_guesses=', num_guesses)\nif abs(guess**3 -cube) >= epsilon:\nprint('Failed on cube root of', cube)\nelse:\nprint(guess, 'is close to the cube root of', cube)\nand guess <= cube :\n6.0001 LECTURE 3\n16\n\nBISECTION SEARCH"
}